### 1. 关于指针的概念，错误的是

A.指针是变量，用来存放地址

B.指针变量中存的有效地址可以唯一指向内存中的一块区域

C.野指针也可以正常使用

D.局部指针变量不初始化就是野指针

**🌟解析：**

```
答案解析：

A：正确，指针变量中存储的是一个地址，指向同类型的一块内存空间

B：正确，地址是唯一的，一个指针变量中只能存储一个地址，因此可以唯一指向内存中的一块区域

C：野指针指向的空间时非法的，或者说该指针指向的空间已经不存在了，因此野指针不能使用

D：局部指针变量没有初始化时里面就是随机值，因此指向那个位置不一定，故将其看成是野指针

因此：选择C
```



### 2. 以下系统中，int类型占几个字节，指针占几个字节，操作系统可以使用的最大内存空间是多大

```
A.32位下：4,4,2^32 64位下：8,8,2^64
B.32位下：4,4,不限制 64位下：4,8,不限制
C.32位下：4,4,2^32 64位下：4,8,2^64
D.32位下：4,4,2^32 64位下：4,4,2^64
```

**🌟解析：**

```
答案解析：

32位系统下：

int占4个字节，指针表示地址空间个数，总共有2^32个，故占4个字节

64位系统下：

int占4个字节，指针表示地址空间个数，总共有2^64个，故占8个字节

因此：选择C
```



### 3. 下面代码的结果是

```c
#include <stdio.h>

int main()
{
  int arr[] = {1,2,3,4,5};
  short *p = (short*)arr;
  int i = 0;
  for(i=0; i<4; i++)
  {
    *(p+i) = 0;
  }
   
  for(i=0; i<5; i++)
  {
    printf("%d ", arr[i]);
  }
  return 0;
}

A. 1 2 3 4 5
B. 0 0 3 4 5
C. 0 0 0 0 5
D. 1 0 0 0 0
```

**🌟解析：**

```
arr数组在内存中的存储格式为：

0x00ECFBF4:  01 00 00 00
0x00ECFBF8:  02 00 00 00
0x00ECFBFC:  03 00 00 00
0x00ECFC00:  04 00 00 00
0x00ECFC04:  05 00 00 00

指针p的类型为short*类型的，因此p每次只能所有两个字节，for循环对数组中内容进行修改时，一次访问的是：

arr[0]的低两个字节，arr[0]的高两个字节，arr[1]的低两个字节，arr[1]的高两个字节，故改变之后，数组中内容如下：

0x00ECFBF4:  00 00 00 00
0x00ECFBF8:  00 00 00 00
0x00ECFBFC:  03 00 00 00
0x00ECFC00:  04 00 00 00
0x00ECFC04:  05 00 00 00

故最后打印：0   0   3   4   5
```



### 4. 下列程序段的输出结果为

```c
unsigned long pulArray[] = {6,7,8,9,10};
unsigned long *pulPtr;
pulPtr = pulArray;
*(pulPtr + 3) += 3;
printf(“%d,%d\n”,*pulPtr, *(pulPtr + 3));

A.9,12
B.6,9
C.6,12
D.6,10
```

**🌟解析：**

```
unsigned long pulArray[] = {6,7,8,9,10};
unsigned long *pulPtr;
pulPtr = pulArray; // 数组名代表数组首元素地址，因此pulptr指向的是数组中第一个元素的位置
*(pulPtr + 3) += 3; // pulptr+3访问的是数组中第三个元素(数组下标从0开始)，故将9改为9+3=12
printf(“%d,%d\n”,*pulPtr, *(pulPtr + 3)); // 打印第一个和第三个元素，因此：打印6和12
```



### 5. 关于二级指针描述描述正确的是

A.二级指针也是指针，只不过比一级指针更大

B.二级指针也是指针，是用来保存一级指针的地址

C.二级指针是用来存放数组的地址

D.二级指针的大小是4个字节

**🌟解析：**

```
答案解析：

A：错误，二级指针是指针，不能说起比一级指针大，只能说二级指针指向的空间中存储的也是一个地址

B：正确

C：错误，数组的地址一般用一级指针存储，或者用数组指针接收

D：二级指针是指针，但是否占4个字节不一定，要看具体的系统

因此：选择B
```



### 6. 下面关于指针运算说法正确的是

A. 整形指针+1，向后偏移一个字节

B. 指针-指针得到是指针和指针之间的字节个数

C. 整形指针解引用操作访问4个字节

D. 指针不能比较大小

**🌟解析：**

```
答案解析：

注意：此题是有问题的，说法不严谨，如果将整形指针理解成int*类型的指针，那么一下说法解析如下

A：错误，整形指针+1，向后便宜一个整形类型的大小，即4个字节

B：错误，两个指针相减，指针必须指向一段连续空间，减完之后的结构代表两个指针之间相差元素的个数

C：正确，整形指向的是一个整形的空间，解引用操作访问4个字节

D：指针中存储的是地址，地址可以看成一个数据，因此是可以比较大小的

因此：选择C
```



### 7. 下面代码输出的结果是

```c
#include <stdio.h>

int main()
{
	int a = 0x11223344;
    char *pc = (char*)&a;
    *pc = 0;
    printf("%x\n", a);
    return 0;
}

A.00223344
B.0
C.11223300
D.112233
```

**🌟解析：**

```
答案解析：
 
假设，a变量的地址为0x64，则a变量在内存中的模型为：

0x64| 44 |
0x65| 33 |
0x66| 22 |
0x67| 11 |
 
char*类型的指针变量pc指向只能指向字符类型的空间，如果是非char类型的空间，必须要将该空间的地址强转为char*类型。
char *pc = (char*)&a; 
pc实际指向的是整形变量a的空间，即pc的内容为0x64，即44，
*pc=0，即将44位置中内容改为0，修改完成之后，a中内容为：0x11223300
 
因此：选择C
```



### 8. 下面哪个是指针数组

```c
A. int* arr[10];
B.int * arr[];
C.int **arr;
D.int (*arr)[10];
```

**🌟解析：**

```
指针数组是一个数组，该数组的每个元素是一个指针

A：正确，定义了一个数组，该数组中有10个元素，每个元素都是int*的指针类型

B：错误，编译失败，定义数组时，要给出空间的大小，如果没有给时，必须要给出初始化结果

C：错误，定义了一个二级指针

D：错误，*和arr先结合，说明arr不是数组。实际上arr是一个指针，一个指向数组的指针。

因此：选择A
```



### 9. 使用指针打印数组内容

>写一个函数打印arr数组的内容，不使用数组下标，使用指针。
>
>arr 是一个整形一维数组。



### 10. 字符串逆序

>写一个函数，可以逆序一个字符串的内容。
>
>[字符逆序](https://www.nowcoder.com/questionTerminal/cc57022cb4194697ac30bcb566aeb47b)



### 11. 计算求和

>求 $Sn=a+aa+aaa+aaaa+aaaaa$ 的前5项之和，其中a是一个数字，
>
>例如：2+22+222+2222+22222



### 12. 打印水仙花数

>求出 $0～100000$ 之间的所有“水仙花数”并输出。
>
>“水仙花数”是指一个n位数，其各位数字的n次方之和确好等于该数本身，如:$153＝1^3 + 5^3 + 3^3$，则153是一个“水仙花数”。



### 13. 打印菱形

>用C语言在屏幕上输出以下图案：
>
>![image-20220608230828082](https://gitee.com/LuvKobe/cloudimg/raw/master/img/202206082308150.png)